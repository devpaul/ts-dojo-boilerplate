{"version":3,"file":"aspect.js","sourceRoot":"","sources":["../../src/aspect.ts"],"names":[],"mappings":"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","sourcesContent":["import { Handle } from './interfaces';\nimport { createHandle } from './lang';\n\n/**\n * An object that provides the necessary APIs to be MapLike\n */\nexport interface MapLike<K, V> {\n\tget(key: K): V;\n\tset(key: K, value?: V): this;\n}\n\n/**\n * An internal type guard that determines if an value is MapLike or not\n *\n * @param value The value to guard against\n */\nfunction isMapLike(value: any): value is MapLike<any, any> {\n\treturn value && typeof value.get === 'function' && typeof value.set === 'function';\n}\n\nexport interface Indexable {\n\t[method: string]: any;\n}\n\n/**\n * The types of objects or maps where advice can be applied\n */\nexport type Targetable = MapLike<string, any> | Indexable;\n\ntype AdviceType = 'before' | 'after';\n\n/**\n * A meta data structure when applying advice\n */\ninterface Advised {\n\tid?: number;\n\tadvice?: Function;\n\tprevious?: Advised;\n\tnext?: Advised;\n\treceiveArguments?: boolean;\n}\n\n/**\n * A function that dispatches advice which is decorated with additional\n * meta data about the advice to apply\n */\ninterface Dispatcher {\n\t[ type: string ]: Advised | undefined;\n\t(): any;\n\ttarget: any;\n\tbefore?: Advised;\n\taround?: Advised;\n\tafter?: Advised;\n}\n\n/**\n * A UID for tracking advice ordering\n */\nlet nextId = 0;\n\n/**\n * Internal function that advises a join point\n *\n * @param dispatcher The current advice dispatcher\n * @param type The type of before or after advice to apply\n * @param advice The advice to apply\n * @param receiveArguments If true, the advice will receive the arguments passed to the join point\n * @return The handle that will remove the advice\n */\nfunction advise(\n\tdispatcher: Dispatcher | undefined,\n\ttype: AdviceType,\n\tadvice: Function | undefined,\n\treceiveArguments?: boolean\n): Handle {\n\tlet previous = dispatcher && dispatcher[type];\n\tlet advised: Advised | undefined = {\n\t\tid: nextId++,\n\t\tadvice: advice,\n\t\treceiveArguments: receiveArguments\n\t};\n\n\tif (previous) {\n\t\tif (type === 'after') {\n\t\t\t// add the listener to the end of the list\n\t\t\t// note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug\n\t\t\twhile (previous.next && (previous = previous.next)) {}\n\t\t\tprevious.next = advised;\n\t\t\tadvised.previous = previous;\n\t\t}\n\t\telse {\n\t\t\t// add to the beginning\n\t\t\tif (dispatcher) {\n\t\t\t\tdispatcher.before = advised;\n\t\t\t}\n\t\t\tadvised.next = previous;\n\t\t\tprevious.previous = advised;\n\t\t}\n\t}\n\telse {\n\t\tdispatcher && (dispatcher[type] = advised);\n\t}\n\n\tadvice = previous = undefined;\n\n\treturn createHandle(function () {\n\t\tlet { previous = undefined, next = undefined } = (advised || {});\n\n\t\tif (dispatcher && !previous && !next) {\n\t\t\tdispatcher[type] = undefined;\n\t\t}\n\t\telse {\n\t\t\tif (previous) {\n\t\t\t\tprevious.next = next;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdispatcher && (dispatcher[type] = next);\n\t\t\t}\n\n\t\t\tif (next) {\n\t\t\t\tnext.previous = previous;\n\t\t\t}\n\t\t}\n\t\tif (advised) {\n\t\t\tdelete advised.advice;\n\t\t}\n\t\tdispatcher = advised = undefined;\n\t});\n}\n\n/**\n * An internal function that resolves or creates the dispatcher for a given join point\n *\n * @param target The target object or map\n * @param methodName The name of the method that the dispatcher should be resolved for\n * @return The dispatcher\n */\nfunction getDispatcher(target: Targetable, methodName: string): Dispatcher {\n\tconst existing = isMapLike(target) ? target.get(methodName) : target && target[methodName];\n\tlet dispatcher: Dispatcher;\n\n\tif (!existing || existing.target !== target) {\n\t\t/* There is no existing dispatcher, therefore we will create one */\n\t\tdispatcher = <Dispatcher> function (this: Dispatcher): any {\n\t\t\tlet executionId = nextId;\n\t\t\tlet args = arguments;\n\t\t\tlet results: any;\n\t\t\tlet before = dispatcher.before;\n\n\t\t\twhile (before) {\n\t\t\t\tif (before.advice) {\n\t\t\t\t\targs = before.advice.apply(this, args) || args;\n\t\t\t\t}\n\t\t\t\tbefore = before.next;\n\t\t\t}\n\n\t\t\tif (dispatcher.around && dispatcher.around.advice) {\n\t\t\t\tresults = dispatcher.around.advice(this, args);\n\t\t\t}\n\n\t\t\tlet after = dispatcher.after;\n\t\t\twhile (after && after.id < executionId) {\n\t\t\t\tif (after.advice) {\n\t\t\t\t\tif (after.receiveArguments) {\n\t\t\t\t\t\tlet newResults = after.advice.apply(this, args);\n\t\t\t\t\t\tresults = newResults === undefined ? results : newResults;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresults = after.advice.call(this, results, args);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tafter = after.next;\n\t\t\t}\n\n\t\t\treturn results;\n\t\t};\n\n\t\tif (isMapLike(target)) {\n\t\t\ttarget.set(methodName, dispatcher);\n\t\t}\n\t\telse {\n\t\t\ttarget && (target[methodName] = dispatcher);\n\t\t}\n\n\t\tif (existing) {\n\t\t\tdispatcher.around = {\n\t\t\t\tadvice: function (target: any, args: any[]): any {\n\t\t\t\t\treturn existing.apply(target, args);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tdispatcher.target = target;\n\t}\n\telse {\n\t\tdispatcher = existing;\n\t}\n\n\treturn dispatcher;\n}\n\n/**\n * Attaches \"after\" advice to be executed after the original method.\n * The advising function will receive the original method's return value and arguments object.\n * The value it returns will be returned from the method when it is called (even if the return value is undefined).\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the original method's return value and arguments object\n * @return A handle which will remove the aspect when destroy is called\n */\nexport function after(target: Targetable, methodName: string, advice: (originalReturn: any, originalArgs: IArguments) => any): Handle {\n\treturn advise(getDispatcher(target, methodName), 'after', advice);\n}\n\n/**\n * Attaches \"around\" advice around the original method.\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the original function\n * @return A handle which will remove the aspect when destroy is called\n */\nexport function around(target: Targetable, methodName: string, advice: ((previous: Function) => Function)): Handle {\n\tlet dispatcher: Dispatcher | undefined = getDispatcher(target, methodName);\n\tlet previous = dispatcher.around;\n\tlet advised: Function | undefined;\n\tif (advice) {\n\t\tadvised = advice(function (this: Dispatcher): any {\n\t\t\tif (previous && previous.advice) {\n\t\t\t\treturn previous.advice(this, arguments);\n\t\t\t}\n\t\t});\n\t}\n\n\tdispatcher.around = {\n\t\tadvice: function (target: any, args: any[]): any {\n\t\t\treturn advised ? advised.apply(target, args) : previous && previous.advice && previous.advice(target, args);\n\t\t}\n\t};\n\n\treturn createHandle(function () {\n\t\tadvised = dispatcher = undefined;\n\t});\n}\n\n/**\n * Attaches \"before\" advice to be executed before the original method.\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the same arguments as the original, and may return new arguments\n * @return A handle which will remove the aspect when destroy is called\n */\nexport function before(target: Targetable, methodName: string, advice: (...originalArgs: any[]) => any[] | void): Handle {\n\treturn advise(getDispatcher(target, methodName), 'before', advice);\n}\n\n/**\n * Attaches advice to be executed after the original method.\n * The advising function will receive the same arguments as the original method.\n * The value it returns will be returned from the method when it is called *unless* its return value is undefined.\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the same arguments as the original method\n * @return A handle which will remove the aspect when destroy is called\n */\nexport function on(target: Targetable, methodName: string, advice: (...originalArgs: any[]) => any): Handle {\n\treturn advise(getDispatcher(target, methodName), 'after', advice, true);\n}\n"]}