{"version":3,"file":"stringExtras.js","sourceRoot":"","sources":["../../src/stringExtras.ts"],"names":[],"mappings":";;;;;;;;;IAAA,uBAAuB,kBAAkB,CAAC,CAAA;IAG1C,IAAM,mBAAmB,GAAG,uBAAuB,CAAC;IACpD,IAAM,gBAAgB,GAAG,OAAO,CAAC;IACjC,IAAM,mBAAmB,GAAG,UAAU,CAAC;IACvC,IAAM,YAAY,GAAiB;QAClC,GAAG,EAAE,OAAO;QACZ,GAAG,EAAE,MAAM;QACX,GAAG,EAAE,MAAM;QACX,GAAG,EAAE,QAAQ;QACb,IAAI,EAAE,OAAO;KACb,CAAC;IAEF;;OAEG;IACH,oBAAoB,IAAY,EAAE,IAAY,EAAE,MAAc,EAAE,SAAuB;QAAvB,yBAAuB,GAAvB,eAAuB;QACtF,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC;YAClB,MAAM,IAAI,SAAS,CAAC,SAAS,GAAG,IAAI,GAAG,2BAA2B,CAAC,CAAC;QACrE,CAAC;QAED,EAAE,CAAC,CAAC,SAAS,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;YAC5B,MAAM,IAAI,SAAS,CAAC,SAAS,GAAG,IAAI,GAAG,sCAAsC,CAAC,CAAC;QAChF,CAAC;QAED,EAAE,CAAC,CAAC,MAAM,GAAG,CAAC,IAAI,MAAM,KAAK,QAAQ,CAAC,CAAC,CAAC;YACvC,MAAM,IAAI,UAAU,CAAC,SAAS,GAAG,IAAI,GAAG,2BAA2B,CAAC,CAAC;QACtE,CAAC;QAED,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC;QACtB,MAAM,CAAC,MAAM,GAAG,CAAC,GAAG,EAAE,GAAG,eAAM,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;IACpD,CAAC;IAED;;;;OAIG;IACH,sBAA6B,IAAY;QACxC,MAAM,CAAC,CAAC,IAAI,GAAG,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,mBAAmB,EAAE,MAAM,CAAC,CAAC;IACjE,CAAC;IAFe,oBAAY,eAE3B,CAAA;IAED;;;;;OAKG;IACH,mBAA0B,GAAW,EAAE,YAA4B;QAA5B,4BAA4B,GAA5B,mBAA4B;QAClE,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YACV,MAAM,CAAC,GAAG,CAAC;QACZ,CAAC;QAED,IAAM,OAAO,GAAG,YAAY,GAAG,mBAAmB,GAAG,gBAAgB,CAAC;QAEtE,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,OAAO,EAAE,UAAU,SAAiB;YACtD,MAAM,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;QAChC,CAAC,CAAC,CAAC;IACJ,CAAC;IAVe,iBAAS,YAUxB,CAAA;IAED;;;;;;OAMG;IACH,gBAAuB,IAAY,EAAE,MAAc,EAAE,SAAuB;QAAvB,yBAAuB,GAAvB,eAAuB;QAC3E,MAAM,CAAC,IAAI,GAAG,UAAU,CAAC,QAAQ,EAAE,IAAI,EAAE,MAAM,EAAE,SAAS,CAAC,CAAC;IAC7D,CAAC;IAFe,cAAM,SAErB,CAAA;IAED;;;;;;OAMG;IACH,kBAAyB,IAAY,EAAE,MAAc,EAAE,SAAuB;QAAvB,yBAAuB,GAAvB,eAAuB;QAC7E,MAAM,CAAC,UAAU,CAAC,UAAU,EAAE,IAAI,EAAE,MAAM,EAAE,SAAS,CAAC,GAAG,IAAI,CAAC;IAC/D,CAAC;IAFe,gBAAQ,WAEvB,CAAA","sourcesContent":["import { repeat } from 'dojo-shim/string';\nimport { Hash } from './interfaces';\n\nconst escapeRegExpPattern = /[[\\]{}()|\\/\\\\^$.*+?]/g;\nconst escapeXmlPattern = /[&<]/g;\nconst escapeXmlForPattern = /[&<>'\"]/g;\nconst escapeXmlMap: Hash<string> = {\n\t'&': '&amp;',\n\t'<': '&lt;',\n\t'>': '&gt;',\n\t'\"': '&quot;',\n\t'\\'': '&#39;'\n};\n\n/**\n * Performs validation and padding operations used by padStart and padEnd.\n */\nfunction getPadding(name: string, text: string, length: number, character: string = '0'): string {\n\tif (text == null) {\n\t\tthrow new TypeError('string.' + name + ' requires a valid string.');\n\t}\n\n\tif (character.length !== 1) {\n\t\tthrow new TypeError('string.' + name + ' requires a valid padding character.');\n\t}\n\n\tif (length < 0 || length === Infinity) {\n\t\tthrow new RangeError('string.' + name + ' requires a valid length.');\n\t}\n\n\tlength -= text.length;\n\treturn length < 1 ? '' : repeat(character, length);\n}\n\n/**\n * Escapes a string so that it can safely be passed to the RegExp constructor.\n * @param text The string to be escaped\n * @return The escaped string\n */\nexport function escapeRegExp(text: string): string {\n\treturn !text ? text : text.replace(escapeRegExpPattern, '\\\\$&');\n}\n\n/**\n * Sanitizes a string to protect against tag injection.\n * @param xml The string to be escaped\n * @param forAttribute Whether to also escape ', \", and > in addition to < and &\n * @return The escaped string\n */\nexport function escapeXml(xml: string, forAttribute: boolean = true): string {\n\tif (!xml) {\n\t\treturn xml;\n\t}\n\n\tconst pattern = forAttribute ? escapeXmlForPattern : escapeXmlPattern;\n\n\treturn xml.replace(pattern, function (character: string): string {\n\t\treturn escapeXmlMap[character];\n\t});\n}\n\n/**\n * Adds padding to the end of a string to ensure it is a certain length.\n * @param text The string to pad\n * @param length The target minimum length of the string\n * @param character The character to pad onto the end of the string\n * @return The string, padded to the given length if necessary\n */\nexport function padEnd(text: string, length: number, character: string = '0'): string {\n\treturn text + getPadding('padEnd', text, length, character);\n}\n\n/**\n * Adds padding to the beginning of a string to ensure it is a certain length.\n * @param text The string to pad\n * @param length The target minimum length of the string\n * @param character The character to pad onto the beginning of the string\n * @return The string, padded to the given length if necessary\n */\nexport function padStart(text: string, length: number, character: string = '0'): string {\n\treturn getPadding('padStart', text, length, character) + text;\n}\n"]}